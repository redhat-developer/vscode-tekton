// tslint:disable
/**
 * Tekton Hub
 * HTTP services for managing Tekton Hub
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuthenticateResponseBody
 */
export interface AuthenticateResponseBody {
    /**
     * JSON Web Token with user details
     * @type {string}
     * @memberof AuthenticateResponseBody
     */
    token: string;
}
/**
 * 
 * @export
 * @interface Catalog
 */
export interface Catalog {
    /**
     * ID is the unique id of the catalog
     * @type {number}
     * @memberof Catalog
     */
    id: number;
    /**
     * Name of catalog
     * @type {string}
     * @memberof Catalog
     */
    name: string;
    /**
     * Type of catalog
     * @type {string}
     * @memberof Catalog
     */
    type: CatalogTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CatalogTypeEnum {
    Official = 'official',
    Community = 'community'
}

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * ID is the unique id of the category
     * @type {number}
     * @memberof Category
     */
    id: number;
    /**
     * Name of category
     * @type {string}
     * @memberof Category
     */
    name: string;
    /**
     * List of tags associated with the category
     * @type {Array<Tag>}
     * @memberof Category
     */
    tags: Array<Tag>;
}
/**
 * 
 * @export
 * @interface GetResponseBody
 */
export interface GetResponseBody {
    /**
     * User rating for resource
     * @type {number}
     * @memberof GetResponseBody
     */
    rating: number;
}
/**
 * Describes the services and their status
 * @export
 * @interface HubService
 */
export interface HubService {
    /**
     * Details of the error if any
     * @type {string}
     * @memberof HubService
     */
    error?: string;
    /**
     * Name of the service
     * @type {string}
     * @memberof HubService
     */
    name: string;
    /**
     * Status of the service
     * @type {string}
     * @memberof HubService
     */
    status: HubServiceStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum HubServiceStatusEnum {
    Ok = 'ok',
    Error = 'error'
}

/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * id of the job
     * @type {number}
     * @memberof Job
     */
    id: number;
    /**
     * status of the job
     * @type {string}
     * @memberof Job
     */
    status: string;
}
/**
 * 
 * @export
 * @interface ListResponseBody
 */
export interface ListResponseBody {
    /**
     * 
     * @type {Array<Category>}
     * @memberof ListResponseBody
     */
    data?: Array<Category>;
}
/**
 * Internal Server Error
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Is the error a server-side fault?
     * @type {boolean}
     * @memberof ModelError
     */
    fault: boolean;
    /**
     * ID is a unique identifier for this particular occurrence of the problem.
     * @type {string}
     * @memberof ModelError
     */
    id: string;
    /**
     * Message is a human-readable explanation specific to this occurrence of the problem.
     * @type {string}
     * @memberof ModelError
     */
    message: string;
    /**
     * Name is the name of this class of errors.
     * @type {string}
     * @memberof ModelError
     */
    name: string;
    /**
     * Is the error temporary?
     * @type {boolean}
     * @memberof ModelError
     */
    temporary: boolean;
    /**
     * Is the error a timeout?
     * @type {boolean}
     * @memberof ModelError
     */
    timeout: boolean;
}
/**
 * 
 * @export
 * @interface RefreshConfigRequestBody
 */
export interface RefreshConfigRequestBody {
    /**
     * Force Refresh the config file
     * @type {boolean}
     * @memberof RefreshConfigRequestBody
     */
    force: boolean;
}
/**
 * 
 * @export
 * @interface RefreshConfigResponseBody
 */
export interface RefreshConfigResponseBody {
    /**
     * Config file checksum
     * @type {string}
     * @memberof RefreshConfigResponseBody
     */
    checksum: string;
}
/**
 * 
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * 
     * @type {ResourceData}
     * @memberof Resource
     */
    data: ResourceData;
}
/**
 * The resource type describes resource information.
 * @export
 * @interface ResourceData
 */
export interface ResourceData {
    /**
     * 
     * @type {Catalog}
     * @memberof ResourceData
     */
    catalog: Catalog;
    /**
     * ID is the unique id of the resource
     * @type {number}
     * @memberof ResourceData
     */
    id: number;
    /**
     * Kind of resource
     * @type {string}
     * @memberof ResourceData
     */
    kind: string;
    /**
     * 
     * @type {ResourceVersionData}
     * @memberof ResourceData
     */
    latestVersion: ResourceVersionData;
    /**
     * Name of resource
     * @type {string}
     * @memberof ResourceData
     */
    name: string;
    /**
     * Rating of resource
     * @type {number}
     * @memberof ResourceData
     */
    rating: number;
    /**
     * Tags related to resource
     * @type {Array<Tag>}
     * @memberof ResourceData
     */
    tags: Array<Tag>;
    /**
     * List of all versions of a resource
     * @type {Array<ResourceVersionData>}
     * @memberof ResourceData
     */
    versions: Array<ResourceVersionData>;
}
/**
 * 
 * @export
 * @interface ResourceVersion
 */
export interface ResourceVersion {
    /**
     * 
     * @type {ResourceVersionData}
     * @memberof ResourceVersion
     */
    data: ResourceVersionData;
}
/**
 * The Version result type describes resource\'s version information.
 * @export
 * @interface ResourceVersionData
 */
export interface ResourceVersionData {
    /**
     * Description of version
     * @type {string}
     * @memberof ResourceVersionData
     */
    description: string;
    /**
     * Display name of version
     * @type {string}
     * @memberof ResourceVersionData
     */
    displayName: string;
    /**
     * ID is the unique id of resource\'s version
     * @type {number}
     * @memberof ResourceVersionData
     */
    id: number;
    /**
     * Minimum pipelines version the resource\'s version is compatible with
     * @type {string}
     * @memberof ResourceVersionData
     */
    minPipelinesVersion: string;
    /**
     * Raw URL of resource\'s yaml file of the version
     * @type {string}
     * @memberof ResourceVersionData
     */
    rawURL: string;
    /**
     * 
     * @type {ResourceData}
     * @memberof ResourceVersionData
     */
    resource: ResourceData;
    /**
     * Timestamp when version was last updated
     * @type {string}
     * @memberof ResourceVersionData
     */
    updatedAt: string;
    /**
     * Version of resource
     * @type {string}
     * @memberof ResourceVersionData
     */
    version: string;
    /**
     * Web URL of resource\'s yaml file of the version
     * @type {string}
     * @memberof ResourceVersionData
     */
    webURL: string;
}
/**
 * 
 * @export
 * @interface ResourceVersions
 */
export interface ResourceVersions {
    /**
     * 
     * @type {Versions}
     * @memberof ResourceVersions
     */
    data: Versions;
}
/**
 * 
 * @export
 * @interface Resources
 */
export interface Resources {
    /**
     * 
     * @type {Array<ResourceData>}
     * @memberof Resources
     */
    data: Array<ResourceData>;
}
/**
 * 
 * @export
 * @interface StatusResponseBody
 */
export interface StatusResponseBody {
    /**
     * List of services and their status
     * @type {Array<HubService>}
     * @memberof StatusResponseBody
     */
    services?: Array<HubService>;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * ID is the unique id of tag
     * @type {number}
     * @memberof Tag
     */
    id: number;
    /**
     * Name of tag
     * @type {string}
     * @memberof Tag
     */
    name: string;
}
/**
 * 
 * @export
 * @interface UpdateAgentRequestBody
 */
export interface UpdateAgentRequestBody {
    /**
     * Name of Agent
     * @type {string}
     * @memberof UpdateAgentRequestBody
     */
    name: string;
    /**
     * Scopes required for Agent
     * @type {Array<string>}
     * @memberof UpdateAgentRequestBody
     */
    scopes: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateRequestBody
 */
export interface UpdateRequestBody {
    /**
     * User rating for resource
     * @type {number}
     * @memberof UpdateRequestBody
     */
    rating: number;
}
/**
 * The Versions type describes response for versions by resource id API.
 * @export
 * @interface Versions
 */
export interface Versions {
    /**
     * 
     * @type {ResourceVersionData}
     * @memberof Versions
     */
    latest: ResourceVersionData;
    /**
     * List of all versions of resource
     * @type {Array<ResourceVersionData>}
     * @memberof Versions
     */
    versions: Array<ResourceVersionData>;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Refresh the changes in config file
         * @summary RefreshConfig admin
         * @param {RefreshConfigRequestBody} refreshConfigRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRefreshConfig: async (refreshConfigRequestBody: RefreshConfigRequestBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshConfigRequestBody' is not null or undefined
            if (refreshConfigRequestBody === null || refreshConfigRequestBody === undefined) {
                throw new RequiredError('refreshConfigRequestBody','Required parameter refreshConfigRequestBody was null or undefined when calling adminRefreshConfig.');
            }
            const localVarPath = `/system/config/refresh`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt_header_Authorization required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof refreshConfigRequestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(refreshConfigRequestBody !== undefined ? refreshConfigRequestBody : {}) : (refreshConfigRequestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or Update an agent user with required scopes
         * @summary UpdateAgent admin
         * @param {UpdateAgentRequestBody} updateAgentRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateAgent: async (updateAgentRequestBody: UpdateAgentRequestBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAgentRequestBody' is not null or undefined
            if (updateAgentRequestBody === null || updateAgentRequestBody === undefined) {
                throw new RequiredError('updateAgentRequestBody','Required parameter updateAgentRequestBody was null or undefined when calling adminUpdateAgent.');
            }
            const localVarPath = `/system/user/agent`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt_header_Authorization required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateAgentRequestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateAgentRequestBody !== undefined ? updateAgentRequestBody : {}) : (updateAgentRequestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Refresh the changes in config file
         * @summary RefreshConfig admin
         * @param {RefreshConfigRequestBody} refreshConfigRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminRefreshConfig(refreshConfigRequestBody: RefreshConfigRequestBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshConfigResponseBody>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).adminRefreshConfig(refreshConfigRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create or Update an agent user with required scopes
         * @summary UpdateAgent admin
         * @param {UpdateAgentRequestBody} updateAgentRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateAgent(updateAgentRequestBody: UpdateAgentRequestBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateResponseBody>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).adminUpdateAgent(updateAgentRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Refresh the changes in config file
         * @summary RefreshConfig admin
         * @param {RefreshConfigRequestBody} refreshConfigRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRefreshConfig(refreshConfigRequestBody: RefreshConfigRequestBody, options?: any): AxiosPromise<RefreshConfigResponseBody> {
            return AdminApiFp(configuration).adminRefreshConfig(refreshConfigRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or Update an agent user with required scopes
         * @summary UpdateAgent admin
         * @param {UpdateAgentRequestBody} updateAgentRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateAgent(updateAgentRequestBody: UpdateAgentRequestBody, options?: any): AxiosPromise<AuthenticateResponseBody> {
            return AdminApiFp(configuration).adminUpdateAgent(updateAgentRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Refresh the changes in config file
     * @summary RefreshConfig admin
     * @param {RefreshConfigRequestBody} refreshConfigRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminRefreshConfig(refreshConfigRequestBody: RefreshConfigRequestBody, options?: any) {
        return AdminApiFp(this.configuration).adminRefreshConfig(refreshConfigRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or Update an agent user with required scopes
     * @summary UpdateAgent admin
     * @param {UpdateAgentRequestBody} updateAgentRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateAgent(updateAgentRequestBody: UpdateAgentRequestBody, options?: any) {
        return AdminApiFp(this.configuration).adminUpdateAgent(updateAgentRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticates users against GitHub OAuth
         * @summary Authenticate auth
         * @param {string} code OAuth Authorization code of User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAuthenticate: async (code: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling authAuthenticate.');
            }
            const localVarPath = `/auth/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Authenticates users against GitHub OAuth
         * @summary Authenticate auth
         * @param {string} code OAuth Authorization code of User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authAuthenticate(code: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateResponseBody>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authAuthenticate(code, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Authenticates users against GitHub OAuth
         * @summary Authenticate auth
         * @param {string} code OAuth Authorization code of User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAuthenticate(code: string, options?: any): AxiosPromise<AuthenticateResponseBody> {
            return AuthApiFp(configuration).authAuthenticate(code, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Authenticates users against GitHub OAuth
     * @summary Authenticate auth
     * @param {string} code OAuth Authorization code of User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authAuthenticate(code: string, options?: any) {
        return AuthApiFp(this.configuration).authAuthenticate(code, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CatalogApi - axios parameter creator
 * @export
 */
export const CatalogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Refreshes Tekton Catalog
         * @summary Refresh catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogRefresh: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/catalog/refresh`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt_header_Authorization required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogApi - functional programming interface
 * @export
 */
export const CatalogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Refreshes Tekton Catalog
         * @summary Refresh catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogRefresh(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await CatalogApiAxiosParamCreator(configuration).catalogRefresh(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CatalogApi - factory interface
 * @export
 */
export const CatalogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Refreshes Tekton Catalog
         * @summary Refresh catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogRefresh(options?: any): AxiosPromise<Job> {
            return CatalogApiFp(configuration).catalogRefresh(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CatalogApi - object-oriented interface
 * @export
 * @class CatalogApi
 * @extends {BaseAPI}
 */
export class CatalogApi extends BaseAPI {
    /**
     * Refreshes Tekton Catalog
     * @summary Refresh catalog
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public catalogRefresh(options?: any) {
        return CatalogApiFp(this.configuration).catalogRefresh(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all categories along with their tags sorted by name
         * @summary list category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all categories along with their tags sorted by name
         * @summary list category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseBody>> {
            const localVarAxiosArgs = await CategoryApiAxiosParamCreator(configuration).categoryList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List all categories along with their tags sorted by name
         * @summary list category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryList(options?: any): AxiosPromise<ListResponseBody> {
            return CategoryApiFp(configuration).categoryList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * List all categories along with their tags sorted by name
     * @summary list category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryList(options?: any) {
        return CategoryApiFp(this.configuration).categoryList(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RatingApi - axios parameter creator
 * @export
 */
export const RatingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Find user\'s rating for a resource
         * @summary Get rating
         * @param {number} id ID of a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling ratingGet.');
            }
            const localVarPath = `/resource/{id}/rating`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt_header_Authorization required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user\'s rating for a resource
         * @summary Update rating
         * @param {number} id ID of a resource
         * @param {UpdateRequestBody} updateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingUpdate: async (id: number, updateRequestBody: UpdateRequestBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling ratingUpdate.');
            }
            // verify required parameter 'updateRequestBody' is not null or undefined
            if (updateRequestBody === null || updateRequestBody === undefined) {
                throw new RequiredError('updateRequestBody','Required parameter updateRequestBody was null or undefined when calling ratingUpdate.');
            }
            const localVarPath = `/resource/{id}/rating`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt_header_Authorization required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateRequestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateRequestBody !== undefined ? updateRequestBody : {}) : (updateRequestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RatingApi - functional programming interface
 * @export
 */
export const RatingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Find user\'s rating for a resource
         * @summary Get rating
         * @param {number} id ID of a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ratingGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetResponseBody>> {
            const localVarAxiosArgs = await RatingApiAxiosParamCreator(configuration).ratingGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update user\'s rating for a resource
         * @summary Update rating
         * @param {number} id ID of a resource
         * @param {UpdateRequestBody} updateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ratingUpdate(id: number, updateRequestBody: UpdateRequestBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RatingApiAxiosParamCreator(configuration).ratingUpdate(id, updateRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RatingApi - factory interface
 * @export
 */
export const RatingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Find user\'s rating for a resource
         * @summary Get rating
         * @param {number} id ID of a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingGet(id: number, options?: any): AxiosPromise<GetResponseBody> {
            return RatingApiFp(configuration).ratingGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user\'s rating for a resource
         * @summary Update rating
         * @param {number} id ID of a resource
         * @param {UpdateRequestBody} updateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingUpdate(id: number, updateRequestBody: UpdateRequestBody, options?: any): AxiosPromise<void> {
            return RatingApiFp(configuration).ratingUpdate(id, updateRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RatingApi - object-oriented interface
 * @export
 * @class RatingApi
 * @extends {BaseAPI}
 */
export class RatingApi extends BaseAPI {
    /**
     * Find user\'s rating for a resource
     * @summary Get rating
     * @param {number} id ID of a resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingApi
     */
    public ratingGet(id: number, options?: any) {
        return RatingApiFp(this.configuration).ratingGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user\'s rating for a resource
     * @summary Update rating
     * @param {number} id ID of a resource
     * @param {UpdateRequestBody} updateRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingApi
     */
    public ratingUpdate(id: number, updateRequestBody: UpdateRequestBody, options?: any) {
        return RatingApiFp(this.configuration).ratingUpdate(id, updateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResourceApi - axios parameter creator
 * @export
 */
export const ResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Find resources using name of catalog, resource name and kind of resource
         * @summary ByCatalogKindName resource
         * @param {string} catalog name of catalog
         * @param {'task' | 'pipeline'} kind kind of resource
         * @param {string} name Name of resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceByCatalogKindName: async (catalog: string, kind: 'task' | 'pipeline', name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalog' is not null or undefined
            if (catalog === null || catalog === undefined) {
                throw new RequiredError('catalog','Required parameter catalog was null or undefined when calling resourceByCatalogKindName.');
            }
            // verify required parameter 'kind' is not null or undefined
            if (kind === null || kind === undefined) {
                throw new RequiredError('kind','Required parameter kind was null or undefined when calling resourceByCatalogKindName.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling resourceByCatalogKindName.');
            }
            const localVarPath = `/resource/{catalog}/{kind}/{name}`
                .replace(`{${"catalog"}}`, encodeURIComponent(String(catalog)))
                .replace(`{${"kind"}}`, encodeURIComponent(String(kind)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find resource using name of catalog & name, kind and version of resource
         * @summary ByCatalogKindNameVersion resource
         * @param {string} catalog name of catalog
         * @param {'task' | 'pipeline'} kind kind of resource
         * @param {string} name name of resource
         * @param {string} version version of resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceByCatalogKindNameVersion: async (catalog: string, kind: 'task' | 'pipeline', name: string, version: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalog' is not null or undefined
            if (catalog === null || catalog === undefined) {
                throw new RequiredError('catalog','Required parameter catalog was null or undefined when calling resourceByCatalogKindNameVersion.');
            }
            // verify required parameter 'kind' is not null or undefined
            if (kind === null || kind === undefined) {
                throw new RequiredError('kind','Required parameter kind was null or undefined when calling resourceByCatalogKindNameVersion.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling resourceByCatalogKindNameVersion.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling resourceByCatalogKindNameVersion.');
            }
            const localVarPath = `/resource/{catalog}/{kind}/{name}/{version}`
                .replace(`{${"catalog"}}`, encodeURIComponent(String(catalog)))
                .replace(`{${"kind"}}`, encodeURIComponent(String(kind)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find a resource using it\'s id
         * @summary ById resource
         * @param {number} id ID of a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resourceById.');
            }
            const localVarPath = `/resource/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find a resource using its version\'s id
         * @summary ByVersionId resource
         * @param {number} versionID Version ID of a resource\&#39;s version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceByVersionId: async (versionID: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'versionID' is not null or undefined
            if (versionID === null || versionID === undefined) {
                throw new RequiredError('versionID','Required parameter versionID was null or undefined when calling resourceByVersionId.');
            }
            const localVarPath = `/resource/version/{versionID}`
                .replace(`{${"versionID"}}`, encodeURIComponent(String(versionID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all resources sorted by rating and name
         * @summary List resource
         * @param {number} [limit] Maximum number of resources to be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceList: async (limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find resources by a combination of name, kind and tags
         * @summary Query resource
         * @param {string} [name] Name of resource
         * @param {Array<string>} [kinds] Kinds of resource to filter by
         * @param {Array<string>} [tags] Tags associated with a resource to filter by
         * @param {number} [limit] Maximum number of resources to be returned
         * @param {'exact' | 'contains'} [match] Strategy used to find matching resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceQuery: async (name?: string, kinds?: Array<string>, tags?: Array<string>, limit?: number, match?: 'exact' | 'contains', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/query`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (kinds) {
                localVarQueryParameter['kinds'] = kinds;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find all versions of a resource by its id
         * @summary VersionsByID resource
         * @param {number} id ID of a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceVersionsByID: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resourceVersionsByID.');
            }
            const localVarPath = `/resource/{id}/versions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceApi - functional programming interface
 * @export
 */
export const ResourceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Find resources using name of catalog, resource name and kind of resource
         * @summary ByCatalogKindName resource
         * @param {string} catalog name of catalog
         * @param {'task' | 'pipeline'} kind kind of resource
         * @param {string} name Name of resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceByCatalogKindName(catalog: string, kind: 'task' | 'pipeline', name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resource>> {
            const localVarAxiosArgs = await ResourceApiAxiosParamCreator(configuration).resourceByCatalogKindName(catalog, kind, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find resource using name of catalog & name, kind and version of resource
         * @summary ByCatalogKindNameVersion resource
         * @param {string} catalog name of catalog
         * @param {'task' | 'pipeline'} kind kind of resource
         * @param {string} name name of resource
         * @param {string} version version of resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceByCatalogKindNameVersion(catalog: string, kind: 'task' | 'pipeline', name: string, version: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceVersion>> {
            const localVarAxiosArgs = await ResourceApiAxiosParamCreator(configuration).resourceByCatalogKindNameVersion(catalog, kind, name, version, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find a resource using it\'s id
         * @summary ById resource
         * @param {number} id ID of a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resource>> {
            const localVarAxiosArgs = await ResourceApiAxiosParamCreator(configuration).resourceById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find a resource using its version\'s id
         * @summary ByVersionId resource
         * @param {number} versionID Version ID of a resource\&#39;s version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceByVersionId(versionID: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceVersion>> {
            const localVarAxiosArgs = await ResourceApiAxiosParamCreator(configuration).resourceByVersionId(versionID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all resources sorted by rating and name
         * @summary List resource
         * @param {number} [limit] Maximum number of resources to be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceList(limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resources>> {
            const localVarAxiosArgs = await ResourceApiAxiosParamCreator(configuration).resourceList(limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find resources by a combination of name, kind and tags
         * @summary Query resource
         * @param {string} [name] Name of resource
         * @param {Array<string>} [kinds] Kinds of resource to filter by
         * @param {Array<string>} [tags] Tags associated with a resource to filter by
         * @param {number} [limit] Maximum number of resources to be returned
         * @param {'exact' | 'contains'} [match] Strategy used to find matching resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceQuery(name?: string, kinds?: Array<string>, tags?: Array<string>, limit?: number, match?: 'exact' | 'contains', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resources>> {
            const localVarAxiosArgs = await ResourceApiAxiosParamCreator(configuration).resourceQuery(name, kinds, tags, limit, match, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find all versions of a resource by its id
         * @summary VersionsByID resource
         * @param {number} id ID of a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceVersionsByID(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceVersions>> {
            const localVarAxiosArgs = await ResourceApiAxiosParamCreator(configuration).resourceVersionsByID(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResourceApi - factory interface
 * @export
 */
export const ResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Find resources using name of catalog, resource name and kind of resource
         * @summary ByCatalogKindName resource
         * @param {string} catalog name of catalog
         * @param {'task' | 'pipeline'} kind kind of resource
         * @param {string} name Name of resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceByCatalogKindName(catalog: string, kind: 'task' | 'pipeline', name: string, options?: any): AxiosPromise<Resource> {
            return ResourceApiFp(configuration).resourceByCatalogKindName(catalog, kind, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Find resource using name of catalog & name, kind and version of resource
         * @summary ByCatalogKindNameVersion resource
         * @param {string} catalog name of catalog
         * @param {'task' | 'pipeline'} kind kind of resource
         * @param {string} name name of resource
         * @param {string} version version of resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceByCatalogKindNameVersion(catalog: string, kind: 'task' | 'pipeline', name: string, version: string, options?: any): AxiosPromise<ResourceVersion> {
            return ResourceApiFp(configuration).resourceByCatalogKindNameVersion(catalog, kind, name, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Find a resource using it\'s id
         * @summary ById resource
         * @param {number} id ID of a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceById(id: number, options?: any): AxiosPromise<Resource> {
            return ResourceApiFp(configuration).resourceById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Find a resource using its version\'s id
         * @summary ByVersionId resource
         * @param {number} versionID Version ID of a resource\&#39;s version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceByVersionId(versionID: number, options?: any): AxiosPromise<ResourceVersion> {
            return ResourceApiFp(configuration).resourceByVersionId(versionID, options).then((request) => request(axios, basePath));
        },
        /**
         * List all resources sorted by rating and name
         * @summary List resource
         * @param {number} [limit] Maximum number of resources to be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceList(limit?: number, options?: any): AxiosPromise<Resources> {
            return ResourceApiFp(configuration).resourceList(limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Find resources by a combination of name, kind and tags
         * @summary Query resource
         * @param {string} [name] Name of resource
         * @param {Array<string>} [kinds] Kinds of resource to filter by
         * @param {Array<string>} [tags] Tags associated with a resource to filter by
         * @param {number} [limit] Maximum number of resources to be returned
         * @param {'exact' | 'contains'} [match] Strategy used to find matching resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceQuery(name?: string, kinds?: Array<string>, tags?: Array<string>, limit?: number, match?: 'exact' | 'contains', options?: any): AxiosPromise<Resources> {
            return ResourceApiFp(configuration).resourceQuery(name, kinds, tags, limit, match, options).then((request) => request(axios, basePath));
        },
        /**
         * Find all versions of a resource by its id
         * @summary VersionsByID resource
         * @param {number} id ID of a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceVersionsByID(id: number, options?: any): AxiosPromise<ResourceVersions> {
            return ResourceApiFp(configuration).resourceVersionsByID(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceApi - object-oriented interface
 * @export
 * @class ResourceApi
 * @extends {BaseAPI}
 */
export class ResourceApi extends BaseAPI {
    /**
     * Find resources using name of catalog, resource name and kind of resource
     * @summary ByCatalogKindName resource
     * @param {string} catalog name of catalog
     * @param {'task' | 'pipeline'} kind kind of resource
     * @param {string} name Name of resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceApi
     */
    public resourceByCatalogKindName(catalog: string, kind: 'task' | 'pipeline', name: string, options?: any) {
        return ResourceApiFp(this.configuration).resourceByCatalogKindName(catalog, kind, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find resource using name of catalog & name, kind and version of resource
     * @summary ByCatalogKindNameVersion resource
     * @param {string} catalog name of catalog
     * @param {'task' | 'pipeline'} kind kind of resource
     * @param {string} name name of resource
     * @param {string} version version of resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceApi
     */
    public resourceByCatalogKindNameVersion(catalog: string, kind: 'task' | 'pipeline', name: string, version: string, options?: any) {
        return ResourceApiFp(this.configuration).resourceByCatalogKindNameVersion(catalog, kind, name, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find a resource using it\'s id
     * @summary ById resource
     * @param {number} id ID of a resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceApi
     */
    public resourceById(id: number, options?: any) {
        return ResourceApiFp(this.configuration).resourceById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find a resource using its version\'s id
     * @summary ByVersionId resource
     * @param {number} versionID Version ID of a resource\&#39;s version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceApi
     */
    public resourceByVersionId(versionID: number, options?: any) {
        return ResourceApiFp(this.configuration).resourceByVersionId(versionID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all resources sorted by rating and name
     * @summary List resource
     * @param {number} [limit] Maximum number of resources to be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceApi
     */
    public resourceList(limit?: number, options?: any) {
        return ResourceApiFp(this.configuration).resourceList(limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find resources by a combination of name, kind and tags
     * @summary Query resource
     * @param {string} [name] Name of resource
     * @param {Array<string>} [kinds] Kinds of resource to filter by
     * @param {Array<string>} [tags] Tags associated with a resource to filter by
     * @param {number} [limit] Maximum number of resources to be returned
     * @param {'exact' | 'contains'} [match] Strategy used to find matching resources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceApi
     */
    public resourceQuery(name?: string, kinds?: Array<string>, tags?: Array<string>, limit?: number, match?: 'exact' | 'contains', options?: any) {
        return ResourceApiFp(this.configuration).resourceQuery(name, kinds, tags, limit, match, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find all versions of a resource by its id
     * @summary VersionsByID resource
     * @param {number} id ID of a resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceApi
     */
    public resourceVersionsByID(id: number, options?: any) {
        return ResourceApiFp(this.configuration).resourceVersionsByID(id, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return status of the services
         * @summary Status status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return status of the services
         * @summary Status status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponseBody>> {
            const localVarAxiosArgs = await StatusApiAxiosParamCreator(configuration).statusStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Return status of the services
         * @summary Status status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStatus(options?: any): AxiosPromise<StatusResponseBody> {
            return StatusApiFp(configuration).statusStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * Return status of the services
     * @summary Status status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusStatus(options?: any) {
        return StatusApiFp(this.configuration).statusStatus(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SwaggerApi - axios parameter creator
 * @export
 */
export const SwaggerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * JSON document containing the API swagger definition
         * @summary Download gen/http/openapi3.yaml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swaggerSchemaSwaggerJson: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/schema/swagger.json`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SwaggerApi - functional programming interface
 * @export
 */
export const SwaggerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * JSON document containing the API swagger definition
         * @summary Download gen/http/openapi3.yaml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async swaggerSchemaSwaggerJson(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SwaggerApiAxiosParamCreator(configuration).swaggerSchemaSwaggerJson(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SwaggerApi - factory interface
 * @export
 */
export const SwaggerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * JSON document containing the API swagger definition
         * @summary Download gen/http/openapi3.yaml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swaggerSchemaSwaggerJson(options?: any): AxiosPromise<void> {
            return SwaggerApiFp(configuration).swaggerSchemaSwaggerJson(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SwaggerApi - object-oriented interface
 * @export
 * @class SwaggerApi
 * @extends {BaseAPI}
 */
export class SwaggerApi extends BaseAPI {
    /**
     * JSON document containing the API swagger definition
     * @summary Download gen/http/openapi3.yaml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwaggerApi
     */
    public swaggerSchemaSwaggerJson(options?: any) {
        return SwaggerApiFp(this.configuration).swaggerSchemaSwaggerJson(options).then((request) => request(this.axios, this.basePath));
    }

}


